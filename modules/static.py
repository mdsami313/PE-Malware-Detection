import pandas as pd
import datetime
import streamlit as st
from signify.authenticode import SignedPEFile
import yara
import lief
import yaml
import hashlib
import pefile
import joblib

import warnings

warnings.filterwarnings("ignore")


def load_config(file_path):
    with open(file_path, "r") as f:
        return yaml.safe_load(f)


config = load_config("config.yaml")
static_config = config['STATIC']

yara_rules_path = static_config['YARA_RULES_PATH']

all_capabilities = ['inject_thread', 'create_process', 'persistence', 'hijack_network', 'create_service', 'create_com_service', 'network_udp_sock', 'network_tcp_listen', 'network_dyndns', 'network_toredo', 'network_smtp_dotNet', 'network_smtp_raw', 'network_smtp_vb', 'network_p2p_win', 'network_tor', 'network_irc', 'network_http', 'network_dropper', 'network_ftp', 'network_tcp_socket', 'network_dns', 'network_ssl', 'network_dga', 'bitcoin', 'certificate', 'escalate_priv','screenshot', 'lookupip', 'dyndns', 'lookupgeo', 'keylogger', 'cred_local', 'sniff_audio', 'cred_ff', 'cred_vnc', 'cred_ie7', 'sniff_lan', 'migrate_apc', 'spreading_file', 'spreading_share', 'rat_vnc', 'rat_rdp', 'rat_telnet', 'rat_webcam', 'win_mutex', 'win_registry', 'win_token', 'win_private_profile', 'win_files_operation', 'Str_Win32_Winsock2_Library', 'Str_Win32_Wininet_Library', 'Str_Win32_Internet_API', 'Str_Win32_Http_API', 'ldpreload', 'mysql_database_presence']

capabilities_descriptions = ['Code injection with CreateRemoteThread in a remote process', 'Create a new process', 'Install itself for autorun at Windows startup', 'Hijack network configuration', 'Create a windows service', 'Create a COM server', 'Communications over UDP network', 'Listen for incoming communication', 'Communications dyndns network', 'Communications over Toredo network', 'Communications smtp', 'Communications smtp', 'Communications smtp', 'Communications over P2P network', 'Communications over TOR network', 'Communications over IRC network', 'Communications over HTTP', 'File downloader/dropper', 'Communications over FTP', 'Communications over RAW socket', 'Communications use DNS', 'Communications over SSL', 'Communication using dga', 'Perform crypto currency mining', 'Inject certificate in store', 'Privilege Escalation', 'Take screenshot','Lookup external IP', 'Dynamic DNS', 'Lookup Geolocation', 'Run a keylogger', 'Steal credential', 'Record Audio', 'Steal Firefox credential', 'Steal VNC credential', 'Steal IE 7 credential', 'Sniff Lan network traffic', 'APC queue tasks migration', 'Malware can spread east-west file', 'Malware can spread east-west using share drive', 'Remote Administration toolkit VNC', 'Remote Administration toolkit enable RDP', 'Remote Administration toolkit enable Telnet', 'Remote Administration toolkit using webcam', 'Create or check mutex', 'Affect system registries', 'Affect system token', 'Affect private profile', 'Affect private profile', 'Match Winsock 2 API library declaration', 'Match Windows Inet API library declaration', 'Match Windows Inet API call', 'Match Windows Http API call', 'Load specified shared libraries', 'This rule checks MySQL database presence']

# Capabilities

capabilities_rules_path = yara_rules_path + '/capabilities/'
capabilities_rules = yara.compile(capabilities_rules_path + 'capabilities.yar')

# Packers

packer_rules_path = yara_rules_path + '/packers/'
packer_compiler_rules = yara.compile(packer_rules_path + 'packer_compiler_signatures.yar')

class PEFile:

    def __init__(self, filename):

        # it uses the LIEF library to parse a binary file specified by the filename variable and stores the result in the binary variable
        binary = lief.parse(filename.__str__()) 

        # function checks if a binary file has a manifest resource; it returns 0 if it doesn't have resources or lacks a manifest, and 1    otherwise
        def has_manifest(binary):
            if binary.has_resources and not binary.resources_manager.has_manifest:
                return 0
            else:
                return 1

        # function checks if a binary file has Address Space Layout Randomization (ASLR) enabled in its optional header, returning 1 if it does, and 0 otherwise.
        def has_aslr(binary):
            if binary.optional_header.has(lief.PE.OptionalHeader.DLL_CHARACTERISTICS.DYNAMIC_BASE):
                return 1
            else:
                return 0

        # function determines if a binary file contains Thread Local Storage (TLS), returning 1 if it does, and 0 otherwise.
        def has_tls(binary):
            if binary.has_tls:
                return 1
            else:
                return 0

        # function checks if a binary file has Data Execution Prevention (DEP) enabled in its optional header, returning 1 if it does, and 0 otherwise.
        def has_dep(binary):
            if binary.optional_header.has(lief.PE.OptionalHeader.DLL_CHARACTERISTICS.NX_COMPAT):
                return 1
            else:
                return 0

        # function checks for suspicious debug timestamps in a binary file; it returns 1 if any debug timestamp is in the future, 0 if no such timestamps are found, and -1 if the binary has no debug information
        def suspicious_dbgts(binary):
            if binary.has_debug:
                debug_list = binary.debug
                for item in debug_list:
                    ts = item.timestamp
                    dbg_time = datetime.datetime.fromtimestamp(ts)
                    if dbg_time > datetime.datetime.now():
                        return 1
                return 0
            else:
                return -1

        # function checks the Code Integrity (CI) settings in a binary file; it returns 0 if the CI catalog value is set to 0xFFFF in the Load Configuration V2 structure, 1 if there is any other configuration present, and -1 if there is no configuration information available.
        def check_ci(binary):
            if binary.has_configuration:
                if isinstance(binary.load_configuration, lief.PE.LoadConfigurationV2) and binary.load_configuration.code_integrity.catalog == 0xFFFF:
                    return 0
                else:
                    return 1
            else:
                return -1

        # function determines if Control Flow Guard (CFG) is supported in a binary file by checking if the GUARD_CF flag is set in its optional header, returning 1 if it is supported and 0 otherwise
        def supports_cfg(binary):
            if binary.optional_header.has(lief.PE.OptionalHeader.DLL_CHARACTERISTICS.GUARD_CF):
                return 1
            else:
                return 0

        # function checks if a PE (Portable Executable) file is digitally signed using the SignedPEFile class, returning 1 if the file is signed and the signature is valid, 0 if the signature is invalid or missing, and -1 if an error occurs during verification.
        def isSigned(filename):
            with open(filename, "rb") as f:
                signed_pe = SignedPEFile(f)
                status, err = signed_pe.explain_verify()
                if status.value == 1:
                    return 1
                elif status.value == 2:
                    return 0
                else:
                    return -1
        
        # This function checks if a file specified by `filename` is packed by matching it against packer/compiler rules, returning 1 if it's packed and 0 otherwise.
        def isPacked(filename):
            matches = packer_compiler_rules.match(filename)
            matches = [m.rule for m in matches]
            if 'IsPacked' in matches:
                return 1
            else:
                return 0

        # This function calculates the SHA-256 hash of a file specified by `filename` using a block size of 65536 bytes, returning the hexadecimal digest of the hash.
        def calculate_sha256(filename, block_size=65536):
            sha256 = hashlib.sha256()
            with open(filename, 'rb') as f:
                for block in iter(lambda: f.read(block_size), b''):
                    sha256.update(block)
            return sha256.hexdigest()

        # Getting The Header Values From The File.
        pe = pefile.PE(filename, fast_load=False)
        self.filename = filename
        self.sha256 = calculate_sha256(filename)
        self.isSigned = isSigned(filename)

        self.isPacked = isPacked(filename)

        self.MajorLinkerVersion = pe.OPTIONAL_HEADER.MajorLinkerVersion
        self.MinorLinkerVersion = pe.OPTIONAL_HEADER.MinorLinkerVersion
        self.SizeOfUninitializedData = pe.OPTIONAL_HEADER.SizeOfUninitializedData
        self.ImageBase = pe.OPTIONAL_HEADER.ImageBase
        self.FileAlignment = pe.OPTIONAL_HEADER.FileAlignment
        self.MajorOperatingSystemVersion = pe.OPTIONAL_HEADER.MajorOperatingSystemVersion
        self.MajorImageVersion = pe.OPTIONAL_HEADER.MajorImageVersion
        self.MinorImageVersion = pe.OPTIONAL_HEADER.MinorImageVersion
        self.MajorSubsystemVersion = pe.OPTIONAL_HEADER.MajorSubsystemVersion
        self.SizeOfImage = pe.OPTIONAL_HEADER.SizeOfImage
        self.SizeOfHeaders = pe.OPTIONAL_HEADER.SizeOfHeaders
        self.CheckSum = pe.OPTIONAL_HEADER.CheckSum
        self.Subsystem = pe.OPTIONAL_HEADER.Subsystem
        self.DllCharacteristics = pe.OPTIONAL_HEADER.DllCharacteristics
        self.SizeOfStackReserve = pe.OPTIONAL_HEADER.SizeOfStackReserve
        self.SizeOfHeapReserve = pe.OPTIONAL_HEADER.SizeOfHeapReserve
        self.NumberOfSections = pe.FILE_HEADER.NumberOfSections
        self.e_cblp = pe.DOS_HEADER.e_cblp
        self.e_lfanew = pe.DOS_HEADER.e_lfanew
        self.SizeOfRawData = sum(map(lambda x: x.SizeOfRawData, pe.sections))
        self.Characteristics = pe.FILE_HEADER.Characteristics
        self.Misc = sum(map(lambda x: x.Misc_VirtualSize, pe.sections))

        try:
            self.BaseOfData = pe.OPTIONAL_HEADER.BaseOfData
        except AttributeError:
            self.BaseOfData = 0

        capabilities = capabilities_rules.match(filename.__str__())
        capabilities = [capability.rule for capability in capabilities]

        for capability in all_capabilities:
            if capability in capabilities:
                exec(f'self.{capability} = 1')
            else:
                exec(f'self.{capability} = 0')

        # Extra Features

        self.has_manifest = has_manifest(binary)
        self.has_aslr = has_aslr(binary)
        self.has_tls = has_tls(binary)
        self.has_dep = has_dep(binary)
        self.code_integrity = check_ci(binary)
        self.supports_cfg = supports_cfg(binary)
        self.suspicious_dbgts = suspicious_dbgts(binary)

        pe.close()
        

    def Build(self):
        item = {}
        for attr, k in self.__dict__.items():
            item[attr] = k
        return item

# Loading The Model And The Features
target_names = joblib.load("labels/static.joblib")
model = joblib.load("models/static.joblib")
features = joblib.load("features/static.joblib")    
scaler = joblib.load("models/static_scaler.joblib")

# This function processes a file by extracting its features using a PEFile object, then constructing a DataFrame and predicting its class using a pre-trained model. It adjusts the result and confidence based on specific conditions, identifies detected capabilities, and returns a tuple containing the predicted class, confidence level, detected capabilities, and result.
def process(file):

    print(f"Target Names: {target_names}")

    try:
        file_name = file.split("/")[-1]
        pe = PEFile(file_name)
        sample = pe.Build()
    except Exception as e:
        print(e)
        return None

    sample_df = pd.DataFrame([sample])
    print(f"Sample DF: {sample_df}")
    print(f"Features: {features}")

    X_sample = sample_df[features].values
    X_sample = scaler.transform(X_sample)

    proba = model.predict_proba(X_sample)
    result = model.predict(X_sample)[0]
    print(f"Result: {result}")
    print(f"probability: {proba}")
    confidence = round(proba[0][result], 2)

    if result != 0 and X_sample[0][0] == 1:
        result = 0

    confidence = round(confidence*100, 2)

    detected_capabilities = []

    for index in range(len(all_capabilities)):
        capability = all_capabilities[index]
        description = capabilities_descriptions[index]
        if sample_df[capability][0] == 1:
            detected_capabilities.append((capability, description))

    return (target_names[result], confidence, detected_capabilities, result)


